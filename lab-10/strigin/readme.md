# Зелёный треугольник

В случае OpenGL (если вы пишете на C++, Rust, и т.п.), вам необходимо установить библиотеку для работы с окнами и пользовательским вводом. Мы рекомендуем использовать SFML. Код инициализации окна можно взять, например, из презентации.

## Порядок действий

1. Инициализировать шейдеры (вершинный и фрагментный)
    Объекты шейдеров создаются функцией glCreateShader.
    Инициализируются исходным кодом функцией glShaderSource
    Компилируется функцией glCompileShader
    Обработать ошибки (см. пункт про обработку ошибок далее)

2. Инициализировать шейдерную программу
    Создаём шейдерную программу: glCreateProgram
    Присоединяем каждый шейдер функцией glAttachShader
    Линкуем программу glLinkProgram
    Обработать ошибки

3. Получить id аттрибутов из шейдерной программы
    Используем функцию glGetAttribLocation
    Если индекс, возвращённый glGetAttribLocation оказался -1, то вы сделали что-то не так

4. Инициализировать VBO
VBO — это массив данных в видеопамяти.
    Создаём VBO: glGenBuffers
    Биндим VBO: glBindBuffer (подробнее об этом далее)
    Заполняем его данными функцией glBufferData

5. Отрисовать сцену
    Установить шейдерную программу текущей: glUseProgram
    Вызываем демонов функцией glEnableVertexAttribArray
    Биндим VBO: glBindBuffer
    Привязываем к нему аттрибут: glVertexAttribPointer
    Можно рисовать: glDrawArrays
    Обработать ошибки

6. Очистить ресурсы
    Когда штуки больше не нужны, их надо удалять
    Удаление шейдерной программы: glDeleteProgram
    Удаление VBO: glDeleteBuffers

## Обработка ошибок

После каждого действия надо спрашивать OpenGL успешно ли он с этим действием справился.
Обработка ошибок компиляции шейдеров

Для получения результатов компиляции каждого шейдера (функция glCompileShader) можно использовать следующую функцию

```c
void ShaderLog(unsigned int shader)
{
    int infologLen = 0;
    glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &infologLen);
    if (infologLen > 1)
    {
        int charsWritten = 0;
        std::vector<char> infoLog(infologLen);
        glGetShaderInfoLog(shader, infologLen, &charsWritten, infoLog.data());
        std::cout << "InfoLog: " << infoLog.data() << std::endl;
    }
}
```

## Обработка других ошибок

Результат большинства функций в OpenGL, которые могут закончиться неудачей, можно получить функцией glGetError. Она возвращает код ошибки, трактовку которого и пример использования функции можно получить в документации.
Обработка ошибок в WebGL

## Биндинг

В процессе работы с различными примитивами OpenGl мы нередко сталкиваемся с функциями вида glBind.... Это работает следующим образом. В памяти OpenGL существует переменная, отвечающая за то, с каким объектом мы работаем в данный момент. Этот объект как раз выбирается функциями glBind....

Например при заполнении VBO мы сначала сообщаем OpenGL, с каким буфером мы сейчас будем работать:

```c
glBindBuffer(GL_ARRAY_BUFFER, VBO);
```

Затем вызываем функцию, заполняющую его данными:

```c
glBufferData(GL_ARRAY_BUFFER, sizeof(triangle), triangle, GL_STATIC_DRAW);
```

Хорошим тоном считается после использования разбиндить буфер, вызвав

```c
glBindBuffer(GL_ARRAY_BUFFER, NULL);
```

## Результат

В ходе этой лабораторной необходимо реализовать отрисовку зелёного треугольника на чёрном фоне с помощью OpenGL и шейдеров.
